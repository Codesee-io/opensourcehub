import path from "path";
import fs from "fs/promises";
import parseFrontMatter from "front-matter";
import invariant from "tiny-invariant";
import type { Project } from "../types";
import { getGitHubDataForProjects } from "./github-data";
import { getRepoOwnerAndName, getSlugFromRepoUrl } from "./repo-url";
import { parseMarkdown } from "./markdown";

function postHasValidAttributes(attributes: any) {
  return (
    attributes.hasOwnProperty("name") &&
    attributes.hasOwnProperty("repoUrl") &&
    attributes.hasOwnProperty("created")
  );
}

async function getAllMdxFiles(dirName: string, files: string[]) {
  const allDirectories = await fs.readdir(dirName);
  for (const fileName of allDirectories) {
    const filePath = path.join(dirName, fileName);
    if ((await fs.stat(path.join(dirName, fileName))).isDirectory()) {
      files = await getAllMdxFiles(filePath, files);
    } else if (fileName.endsWith(".mdx")) {
      files.push(dirName + "/" + fileName);
    }
  }

  return files;
}

const CONTRIBUTING_TAGS = ["<Contributing>", "</Contributing>"];
const OVERVIEW_TAGS = ["<Overview>", "</Overview>"];

function extractSectionFromContent(
  content: string,
  startTag: string,
  endTag: string
) {
  if (content.includes(startTag) && content.includes(endTag)) {
    const from = content.indexOf(startTag) + startTag.length;
    const to = content.indexOf(endTag);
    return content.slice(from, to).trim();
  }
  return "";
}

async function exportProjectsToJson() {
  // We'll store data in the directory below, so we make sure it exists
  const outputDirectory = path.join(__dirname, "../data/autogenerated");
  try {
    await fs.mkdir(outputDirectory);
  } catch (_) {}

  const projectsPath = path.join(__dirname, "../../public/projects");

  // Get all the mdx files inside the projects directory
  const allMdxFiles = await getAllMdxFiles(projectsPath, []);

  // Remove the template file
  const allProjects = allMdxFiles.filter(
    (f) => f !== path.join(projectsPath, "_template.mdx")
  );

  const projectsData = await Promise.all(
    allProjects.map(async (fileName) => {
      const file = await fs.readFile(path.join(fileName));

      const { attributes, body } = parseFrontMatter<{
        repoUrl: string;
        name: string;
        maintainer: string;
        created: string;
        [key: string]: any;
      }>(file.toString());

      invariant(
        postHasValidAttributes(attributes),
        `${fileName} has invalid frontmatter`
      );

      const slug = getSlugFromRepoUrl(attributes.repoUrl);
      const { owner } = getRepoOwnerAndName(attributes.repoUrl);
      if (attributes.avatar) {
        const splitPath = fileName.split("/");
        const parentFolder = splitPath[splitPath.length - 2];
        attributes.avatar =
          "/projects/" + parentFolder + "/" + attributes.avatar;
      }

      // Parse the <Contributing> and <Overview> sections in the markdown
      let contributing = extractSectionFromContent(
        body,
        CONTRIBUTING_TAGS[0],
        CONTRIBUTING_TAGS[1]
      );
      contributing = parseMarkdown(contributing);

      let overview = extractSectionFromContent(
        body,
        OVERVIEW_TAGS[0],
        OVERVIEW_TAGS[1]
      );
      overview = parseMarkdown(overview);

      const project: Project = {
        slug,
        attributes,
        body: {
          contributing,
          overview,
        },
        organization: owner,
      };
      return project;
    })
  );

  // The paths of the data files we're about to output
  const outputProjectsPath = path.join(outputDirectory, "projects.json");
  const outputGithubPath = path.join(outputDirectory, "github.json");

  // Grab a bunch of information from GitHub if we have the right env vars
  const { githubDataSet, invalidProjectSlugs } = await getGitHubDataForProjects(
    projectsData
  );

  if (githubDataSet != null) {
    // Check whether the file already exists
    let fileExists: boolean;
    try {
      await fs.access(outputGithubPath);
      fileExists = true;
    } catch (_) {
      fileExists = false;
    }

    // Check whether the data we want to store is an empty object
    const dataIsEmpty = Object.keys(githubDataSet).length === 0;

    // Write to the file system unless the data is empty and the file exists
    if (!(dataIsEmpty && fileExists)) {
      console.log(`Writing to ${outputGithubPath}`);
      await fs.writeFile(
        outputGithubPath,
        JSON.stringify(githubDataSet, null, 2)
      );
    }
  }

  // Remove the invalid projects
  const validProjects = projectsData.filter(
    (project) => !invalidProjectSlugs.has(project.slug)
  );

  console.log(
    `Writing ${validProjects.length} projects to ${outputProjectsPath}`
  );

  await fs.writeFile(
    outputProjectsPath,
    JSON.stringify(validProjects, null, 2)
  );
}

exportProjectsToJson();
