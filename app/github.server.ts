import { graphql } from "@octokit/graphql";
import { Octokit } from "@octokit/rest";
import type { graphql as GraphQLType } from "@octokit/graphql/dist-types/types";
import githubData from "./data/autogenerated/github.json";
import type { GitHubData, PullRequestDetails } from "./types";

export function getGitHubData() {
  return githubData as { [key: string]: GitHubData };
}

export function getGitHubDataForProject(slug: string) {
  return getGitHubData()[slug] || undefined;
}

let graphqlAPI: GraphQLType;

function getGithubAPI() {
  if (!process.env.GITHUB_PERSONAL_ACCESS_TOKEN) {
    throw new Error("Missing GITHUB_PERSONAL_ACCESS_TOKEN");
  }

  if (!graphqlAPI) {
    graphqlAPI = graphql.defaults({
      headers: {
        authorization: `token ${process.env.GITHUB_PERSONAL_ACCESS_TOKEN}`,
      },
    });
  }

  return graphqlAPI;
}

export async function getPullRequestInfo(
  repoOwner: string,
  repoName: string,
  pullRequestNumber: string
) {
  type ReturnValue = {
    repository: {
      pullRequest: PullRequestDetails;
    };
  };

  const value = await getGithubAPI()<ReturnValue>(
    `
    query pullRequestDetails($owner: String!, $name: String!, $pullRequestNumber: Int!) {
      repository(name: $name, owner: $owner) {
        pullRequest(number: $pullRequestNumber) {
          author {
            login
            url
          }
          url
          number
          merged
          title
          participants(first:100) {
            nodes {
              login
            }
          }
          repository {
            nameWithOwner
            url
          }
        }
      }
    }
  `,
    {
      owner: repoOwner,
      name: repoName,
      pullRequestNumber: parseInt(pullRequestNumber, 10),
    }
  );

  return value.repository.pullRequest;
}

const TARGET_OWNER = "Codesee-io";
const TARGET_REPO = "opensourcehub";

export type FileToUpload = {
  content: string;
  filePath: string;
  encoding: "utf-8" | "base64";
};

/**
 * Create a new branch with a new commit that contains one or more files, and
 * then open a pull request as the current user.
 *
 * I want to thank the GitHub API for making this needlessly difficult.
 */
export async function createNewPullRequest(
  accessToken: string,
  files: FileToUpload[],
  projectDirectory: string,
  projectName: string
) {
  if (!accessToken) {
    throw new Error(
      "Please provide a valid accessToken to createNewPullRequest()"
    );
  }

  const octokit = new Octokit({
    auth: accessToken,
  });

  // Create a blob for each file
  const allFileBlobs = await Promise.all(
    files.map((file) =>
      octokit.request("POST /repos/{owner}/{repo}/git/blobs", {
        owner: TARGET_OWNER,
        repo: TARGET_REPO,
        content: file.content,
        encoding: file.encoding,
      })
    )
  );

  // Grab a reference to the main branch of the repo
  const { data: mainRef } = await octokit.request(
    "GET /repos/{owner}/{repo}/git/ref/{ref}",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      ref: `heads/main`,
    }
  );

  const branchName = `project/add-${projectName.toLowerCase()}-${Date.now()}`;

  // Create a new branch
  const { data: branch } = await octokit.request(
    "POST /repos/{owner}/{repo}/git/refs",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      ref: `refs/heads/${branchName}`,
      sha: mainRef.object.sha,
    }
  );

  // Grab the tree of the branch we just created
  const { data: originalTree } = await octokit.request(
    "GET /repos/{owner}/{repo}/git/trees/{tree_sha}",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      tree_sha: branch.object.sha,
    }
  );

  // Create a new tree based on the branch -- this basically tells git how to
  // structure the hierarchy of the files we're creating.
  const { data: updatedTree } = await octokit.request(
    "POST /repos/{owner}/{repo}/git/trees",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      base_tree: originalTree.sha,
      tree: files.map((file, index) => ({
        path: `public/projects/${projectDirectory}/${file.filePath}`,
        mode: "100644" as "100644",
        type: "blob" as "blob",
        sha: allFileBlobs[index].data.sha,
      })),
    }
  );

  // Commit the new tree
  const { data: commit } = await octokit.request(
    "POST /repos/{owner}/{repo}/git/commits",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      message: `List the "${projectName}" project`,
      tree: updatedTree.sha,
      parents: [branch.object.sha],
    }
  );

  // Update the new branch with the ref to the commit
  await octokit.request("PATCH /repos/{owner}/{repo}/git/refs/{ref}", {
    owner: TARGET_OWNER,
    repo: TARGET_REPO,
    ref: `heads/${branchName}`, // Don't prefix with "ref/"
    sha: commit.sha,
  });

  // Create a pull request
  const { data: createPRData } = await octokit.request(
    "POST /repos/{owner}/{repo}/pulls",
    {
      owner: TARGET_OWNER,
      repo: TARGET_REPO,
      title: `[project] Add ${projectName}`,
      head: branchName,
      base: "main",
      body: `### Add a new project to Open Source Hub :tada:

Repository: https://github.com/${projectDirectory}/${projectName}
`,
      maintainer_can_modify: true,
    }
  );

  // Return the URL of the new pull request
  return {
    pullRequestUrl: createPRData.html_url,
  };
}
